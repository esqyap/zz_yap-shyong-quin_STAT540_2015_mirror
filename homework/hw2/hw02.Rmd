---
title: "hw02"
author: "Eva Y"
date: "March 21, 2015"
output:
  html_document:
    keep_md: yes
---

## Attach packages
```{r, message=FALSE, warning=FALSE}
library(car)
library(edgeR)
library(gplots)
library(ggplot2)
library(GGally)
library(lattice)
library(limma)
library(RColorBrewer)
library(reshape2)
library(yeast2.db)
```

## Q1 Microarray analysis

### Q1a) (0 points) Load Microarray Data

> Load the normalized data.

```{r}
# load normalized microarray data
mdat <- read.table("../../data/GSE37599-data.tsv", header=TRUE, row.names=1)

# what is the flavour of the dataset? 
str(mdat)
```

> What are dimensions of the dataset?

```{r}
dim(mdat)
```

> In addition to reporting number of rows and columns, make it clear what rows and columns represent and how you're interpreting column names.**

```{r}
# what are the column names?
colnames(mdat)

# what are the row names?
head(row.names(mdat))
```

Based on this exploratory analysis, this dataset consists of 10928 rows and 6 columns. The rows represent the probes measured by the microarray platform whereas the columns represent yeast samples in the experiment. Three samples are labelled with "b" followed by 1-3. These are yeast samples grown in batch medium and the number following the letter represents the sample replicates. There are also three samples labelled with "c" followed by 1-3. These are yeast samples grown in the chemostat setup and the number following the letter represents the sample replicates. There are three replicates for each growth condition(total samples = 6).

### Q1b) (1 point) Identify Sample Swap

> The labels on two of the samples have been swapped, that is one of the batch samples has been labelled as chemostat and vice-versa. Produce the plots described below and explain how they allow you to identify the swapped samples.

> i. (High volume) scatter plot matrix.

```{r}
ggpairs(mdat)
```

From the far-left column of the scatter plot matrix, we can be observed that b1 is more highly correlated with c1 and c3 compared to b2 and b3. From the second last row, we can be observed that c2 is more highly correlated to b2 and b3 compared to c1. From the correlation plot between c2 and c3 (last row, second from the right), we can also be observed that c2 is less correlated to c3. 

> ii. A heatmap of the first 100 genes (you can try more but it gets slow).

```{r, message=FALSE, warning=FALSE}
# create data frame for heatmap.2
mdat_100 <- as.matrix(mdat[1:100, ])

# extract sample names
sample_name <- data.frame(sample=colnames(mdat_100))

# color palette 
jSpectral <- colorRampPalette(brewer.pal(n=9, "Spectral"))
palette_size <- 256
spec_palette <- jSpectral(palette_size)

# specify color labels for different samples
sample_cols <- brewer.pal(11, "RdGy")[c(2,3,4,8,9,10)]

# plot heatmap
heatmap.2(mdat_100, col=spec_palette, 
          trace="none", 
          ColSideColors=sample_cols[unclass(sample_name$sample)],
          main="Heatmap of 100 genes",
          margin=c(4,10))

# add legend
legend("topright", legend = levels(sample_name$sample),
       col=sample_cols, ncol=2, lty=1, lwd=5, cex=0.5)
```

From the heatmap, we can be observed that c2 clusters with b2 and b3 whereas b1 clusters with c1 and c3. 

> iii. Compute the Pearson correlation of the samples and plot the results using a heatmap.

```{r}
# functionalize this step because it is required in the future
pcorr <- function(data){
  # compute Pearson's correlation between samples
  pcorr_dat <- cor(data)
  diag(pcorr_dat) <- NA
  
  # plot heatmap
  heatmap.2(pcorr_dat, col=spec_palette,
          trace="none",
          ColSideColors=sample_cols[unclass(sample_name$sample)], 
          RowSideColors=sample_cols[unclass(sample_name$sample)],
          margin=c(4,10))
  
  # add legend
  legend("topright", legend=levels(sample_name$sample),
       col=sample_cols, ncol=2, border=FALSE,
       lty=1, lwd=5, cex=0.5)
}

# compute for dataset with swapped samples
pcorr(mdat)
```

The heatmap showing Pearson's correlation between samples also demonstrated that c2 clusters with b2 and b3 while b1 clusters with c1 and c3. 

> iv. Scatterplot the six data samples with respect to the first two principal components and label the samples.

```{r}
# perform pca
pca <- prcomp(mdat)

# extract PC1 and PC2
pca_df <- data.frame(pca$rotation)[ ,1:2]

# make data frame for plotting
pca_df <- data.frame(condition=rep(c("batch", "chemostat"), each=3), pca_df)

# plot pca with respect to the first two principal components
ggplot(pca_df, aes(x=PC1, y=PC2, color=condition, label=rownames(pca_df))) +
  geom_text()
```

Lastly, the scatterplot of the first two principal components showed that b1 clusters with c1 and c3 whereas c2 clusters with b2 and b3. 

In conclusion, all four plots showed that there is a sample swap between b1 and c2.

### Q1c) (2 points) Microarray Differential Expression

>  Fix the label swap identified in question 1b. We want to swap b1 <--> c2. Revisit one or more elements of question 1b to sanity check before proceeding.

Now to fix the label swap and some sanity check before proceeding.
```{r}
# fix label swap
mdat_fix <- with(mdat, data.frame(row.names=row.names(mdat), 
                                  b1=mdat$c2, b2=mdat$b2, 
                                  b3=mdat$b3, c1=mdat$c1, 
                                  c2=mdat$b1, c3=mdat$c3))
```

Time to revisit one or more elements of question 1b to sanity check before proceeding...I pick the heatmap showing Pearson's correlation between samples. 
```{r}
pcorr(mdat_fix)
```

The samples are clustered in the correct groups. Unlike the previous heatmap depicting Pearson's correlation between samples, we can see that the grey labels (chemostat growth condition) are clustered together while red labels (batch medium) are clustered together.

Everything checked out. Good to go!

> Now use this data to do a differential expression analysis with `limma`.

First, we need to generate a design matrix before fitting the linear model. 
```{r}
# create metadata
metadata <- data.frame(sample=colnames(mdat), condition=rep(c("batch", "chemostat"), each=3))

# create design matrix
design <- model.matrix(~condition, metadata)
str(design)

# fit the linear model
fit <- lmFit(mdat_fix, design)

# apply eBayes() to moderate the estimated error variances
ebfit <- eBayes(fit)
```

> Package these results in a data frame with six columns:

> - probe.id - The array probe id.
  - gene.id - The id of the gene which the probe overlaps (see below).
  - p.value - The raw p-value for the probe.
  - q.value - The BH corrected p-value, aka the q-value.
  - log.fc - The log fold change which is the column called "logFC" in the limma results table.
  - test.stat - The test statistics which for limma is the moderated t statistic. This is the column called "t" in the limma results table.

Now to extract output of the linear model using `topTable()`.
```{r, message=FALSE}
top <- topTable(ebfit, number=Inf)
```

We can retrive the gene IDs from the `yeast2ORF` object from the `yeast2.db` package and construct the data frame described above.
```{r, message=FALSE, warning=FALSE}
# retrive gene IDs from yeast2ORF
probe_id <- row.names(top)
gene_id <- unlist(mget(probe_id, yeast2ORF))

# make data frame
top <- data.frame(probe.id=probe_id, gene.id=gene_id,
                     p.value=top$P.Value, q.value=top$adj.P.Val,
                     log.fc=top$logFC, test.stat=top$t)

# check dimensions of the dataframe
str(top, max.level=0)
```

> Remove any rows with probes which don't map to genes. You'll be able to find these because they will have NA as their gene id. Work with this data.frame to answer the questions below.

Based on the description above, let's filter out rows with NA as their gene IDs.
```{r}
# filter out NA values
top_filter <- subset(top, top$gene.id != "NA")

# check dimensions of the filtered dataset
str(top_filter, max.level=0)
```

> i. How many probes did we start with and how many remain after removing probes without gene ids?

```{r}
# pre-filtered datasets 
nrow(top)

# dataset without NA values as gene IDs
nrow(top_filter)
```

We started with `r nrow(top)` probes and we are left with `r nrow(top_filter)` after filtering out gene IDs with NA values. 

> ii. Illustrate the differential expression between the batch and the chemostat samples for the top hit (i.e., probe with the lowest p- or q-value).

```{r, message=FALSE}
# top hit with lowest q-value
top_hit <- top_filter$probe.id[1]

# select gene expression for the probe for all samples from mdat
top_hit <- mdat_fix[top_hit, ]

# make data frame tall and skinny
top_hit <- melt(top_hit)
top_hit <- cbind(gene=rep(top_filter$probe.id[1], 
                          each=nrow(top_hit)), 
                 condition=metadata$condition, top_hit)

# plot 
ggplot(top_hit, aes(x=condition, y=value)) + 
  geom_point() +
  facet_wrap(~gene) +
  stat_summary(aes(group=1), fun.y=mean, geom="line") +
  ylab("Gene expression") +
  xlab("Growth condition") 
```

> iii. How many probes are identified as differentially expressed at a false discovery rate (FDR) of 1e-05 (note: this is a FDR cutoff used in the original paper)?

```{r}
# number of probes with FDR < 1e-05
nrow(subset(top_filter, q.value < 1e-05))
```

At FDR < 1e-05, there are `r nrow(subset(top_filter, q.value < 1e-05))` differentially expressed genes between yeast samples grown under batch medium and chemostat setup. 

> iv. Save your results for later with write.table().

```{r}
# save differentially expressed genes with FDR < 1e-05
dea_fdr <- subset(top_filter, q.value < 1e-05)

write.table(dea_fdr, "micro.limma.results.tsv", row.names=TRUE, col.names=NA)
```


## Q2 RNA-Seq Analysis

### Q2a) (1 point) Load RNA Count Data and Sanity Check

> Load the count data. 

```{r}
# load count data
cdat <- read.table("../../data/stampy.deep.counts.tsv", header=TRUE, row.names=1)

# what is the flavour of the dataset? 
str(cdat)
```

> i) What are dimensions of the dataset? In addition to reporting number of rows and columns, make it clear what rows and columns represent. What is the difference between the rows of this dataset versus rows of the array data in question 1a?

```{r}
# dimensions of the dataset
dim(cdat)

# what do the columns represent? 
colnames(cdat)

# what do the rows represent?
head(row.names(cdat))
```

The count dataset has `r nrow(cdat)` rows and `r ncol(cdat)` columns. The columns represent the 6 yeast samples grown under batch medium (b group) and chemostat setup (c group). Unlike the rows in the microarray data which represent probe IDs, the rows in the count data represent sequence annotations on the yeast reference genome. While the numeric values in the microarray data are gene expression, the numeric values in the count data are number of reads. 

> ii) Do a sanity check to make sure there is no sample swap by plotting a heatmap of the sample correlations.

```{r}
# use pcorr() function to do this
pcorr(cdat)
```

Grey labels (c group) are clustered together whereas red labels (b group) are clustered together. No sample swap is identified, we can move on.

### Q2b) (2 points) voom Differential Expression Analysis

> Use voom+limma to identify differentially expressed genes between the batch medium vs. chemostat conditions.

> i) voom normalizes the counts before it converts counts to log2-cpm. Use calcNormFactors to normalize counts.

```{r}
# normalize counts
norm_factor <- calcNormFactors(cdat)
```

> ii) Use voom to convert count data into logged CPM data and then use limma to identify differentially expressed genes between conditions.

```{r}
# convert count data to logged CPM using voom()
cdat_norm <- voom(cdat, design, plot=TRUE,
                  lib.size=colSums(cdat)*norm_factor)
```

Now, we can use `limma` to get differentially expressed genes between conditions. 
```{r}
# fit the linear model
fit <- lmFit(cdat_norm, design)

# apply eBayes() to moderate the estimated error variances
ebfit <- eBayes(fit)
```

> Package these results in a data.frame called 'voom.limma.deep.results' with five columns:
  
> - gene.id - The id of the gene which reads were aligned to.
  - p.value - The raw p-value for the gene.
  - q.value - The BH corrected p-value, aka the q-value.
  - log.fc - The log fold change which is the column called "logFC" in the edgeR results table.
  - test.stat - The test statistic, which is the column called "t".

Time to package the data as described in the instructions above.
```{r, message=FALSE, warning=FALSE}
# use topTable to extract output of the linear model
top <- topTable(ebfit, number=Inf)

# create data frame
voom.limma.deep.results <- data.frame(gene.id=row.names(top),
                                      p.value=top$P.Value, 
                                      q.value=top$adj.P.Val,
                                      log.fc=top$logFC,
                                      test.stat=top$t)
```

> iii) How many genes are differentially expressed between conditions at a false discovery rate (FDR) of 1e-05?

```{r}
# number of genes with FDR < 1e-05
nrow(subset(voom.limma.deep.results, q.value < 1e-05))
```

There are `r nrow(subset(voom.limma.deep.results, q.value < 1e-05))` genes that are differentially expressed between conditions at FDR < 1e-05. 

> iv) Save your results for later with write.table() in file called stampy.deep.limma.results.tsv.

```{r}
# save differentially expressed genes with FDR < 1e-05
dea_fdr <- subset(voom.limma.deep.results, q.value < 1e-05)

write.table(dea_fdr, "stampy.deep.limma.results.tsv", row.names=TRUE, col.names=NA)
```


## Q3) Compare DEA results between RNA-Seq and array

### Q3a) (1 point) Comparing volumes of DE genes

> In this question, you will examine the difference between the q-values from both analyses (i.e., array and voom+limma) by overlaying density plots of the q-values from each analysis.

Load both data sets.
```{r}
# microarray
mlimma <- read.table("micro.limma.results.tsv", header=T, row.names=1)
  
# RNA seq
rseqlimma <- read.table("stampy.deep.limma.results.tsv", header=T, row.names=1)
```

Generate density plot that represents q.values of genes analyzed by both platforms.
```{r}
# what are the genes analyzed by both platforms?
micro_rseq <- intersect(mlimma$gene.id, rseqlimma$gene.id)

# make data frame for plotting

```

> Make some observations about the strengths of these two platforms.

### Q3b) (2 points) Plots

> Plot the gene expression (i.e., from array data) and the logged counts (i.e., from RNA-Seq data) of: two interesting genes identified as DE by both analyses; one DE gene identified as DE only in the array analysis; one DE gene only in the voom+limma analysis; one boring gene in both analyses (i.e., 5 genes total measured with 2 platforms)

```{r}

```


